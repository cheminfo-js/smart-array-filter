{"version":3,"file":"smart-array-filter.min.js","sources":["../node_modules/.pnpm/lodash.escaperegexp@4.1.2/node_modules/lodash.escaperegexp/index.js","../src/getCheckNumber.js","../src/getCheckString.js","../src/parseKeywords.js","../src/index.js"],"sourcesContent":["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = toString(string);\n  return (string && reHasRegExpChar.test(string))\n    ? string.replace(reRegExpChar, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n","const operators = {\n  '<': (query) => {\n    return function (number) {\n      return number < query;\n    };\n  },\n  '<=': (query) => {\n    return function (number) {\n      return number <= query;\n    };\n  },\n  '=': (query) => {\n    return function (number) {\n      return number === query;\n    };\n  },\n  '>=': (query) => {\n    return function (number) {\n      return number >= query;\n    };\n  },\n  '>': (query) => {\n    return function (number) {\n      return number > query;\n    };\n  },\n};\n\n// we also deal with ..10 and 10..\noperators['..'] = operators['<='];\n\nexport default function getCheckNumber(keyword) {\n  let match = /^\\s*\\(?\\s*(<|<=|=|>=|>|\\.\\.)?(-?\\d*\\.?\\d+)(?:(\\.\\.)(-?\\d*\\.?\\d*))?\\s*\\)?\\s*$/.exec(\n    keyword,\n  );\n  let checkNumber = () => false;\n  if (match) {\n    let operator = match[1];\n    let query = parseFloat(match[2]);\n    let dots = match[3];\n    let secondQuery = match[4];\n    if (operator) {\n      checkNumber = operators[operator](query);\n    } else if (dots) {\n      if (secondQuery !== '') {\n        secondQuery = parseFloat(secondQuery);\n        checkNumber = function (number) {\n          return query <= number && number <= secondQuery;\n        };\n      } else {\n        checkNumber = operators['>='](query);\n      }\n    } else {\n      checkNumber = operators['='](query);\n    }\n  }\n  return checkNumber;\n}\n","import escapeRegExp from 'lodash.escaperegexp';\n\nconst operators = {\n  '<': (query) => {\n    return function (string) {\n      return string < query;\n    };\n  },\n  '<=': (query) => {\n    return function (string) {\n      return string <= query;\n    };\n  },\n  '=': (query, insensitive) => {\n    query = `^${escapeRegExp(query)}$`;\n    const reg = new RegExp(query, insensitive);\n\n    return function (string) {\n      return reg.test(string);\n    };\n  },\n  '~': (query, insensitive) => {\n    query = escapeRegExp(query);\n    const reg = new RegExp(query, insensitive);\n\n    return function (string) {\n      return reg.test(string);\n    };\n  },\n  '>=': (query) => {\n    return function (string) {\n      return string >= query;\n    };\n  },\n  '>': (query) => {\n    return function (string) {\n      return string > query;\n    };\n  },\n};\n\noperators['..'] = operators['<='];\n\nexport default function getCheckString(keyword, insensitive) {\n  let match = /^\\s*\\(?\\s*(<|<=|=|>=|>|\\.\\.)?([a-zA-Z0-9_-]+)([a-zA-Z(?:(\\.\\.)0-9_-]+)?\\s*\\)?$/.exec(\n    keyword,\n  );\n  let checkString = () => false;\n  if (match) {\n    let operator = match[1];\n    let query = match[2];\n    let dots = match[3];\n    let secondQuery = match[4];\n    if (operator) {\n      checkString = operators[operator](query, insensitive);\n    } else if (dots) {\n      if (secondQuery !== '') {\n        secondQuery = parseFloat(secondQuery);\n        checkString = function (string) {\n          return query <= string && string <= secondQuery;\n        };\n      } else {\n        checkString = operators['>='](query, insensitive);\n      }\n    } else {\n      checkString = operators['~'](query, insensitive);\n    }\n  }\n  return checkString;\n}\n","let separators = /[ ;,\\t\\r\\n]/;\n\nexport default function parseKeywords(keywords) {\n  let result = [];\n  let inQuotes = false;\n  let inSeparator = true;\n  let currentWord = [];\n  let previous = '';\n  for (let i = 0; i < keywords.length; i++) {\n    let current = keywords.charAt(i);\n    if (inQuotes) {\n      if (previous === '\"') {\n        // escaped quote\n        if (current === '\"') {\n          previous = '';\n          continue;\n        }\n        // end of quoted part\n        currentWord.pop(); // remove last quote that was added\n        inQuotes = false;\n        i--;\n        continue;\n      }\n      currentWord.push(current);\n      previous = current;\n      continue;\n    }\n    if (inSeparator) {\n      // still in separator ?\n      if (separators.test(current)) {\n        previous = current;\n        continue;\n      }\n      inSeparator = false;\n    }\n    // start of quoted part\n    if (current === '\"') {\n      inQuotes = true;\n      previous = '';\n      continue;\n    }\n    // start of separator part\n    if (separators.test(current)) {\n      if (currentWord.length) result.push(currentWord.join(''));\n      currentWord = [];\n      inSeparator = true;\n      continue;\n    }\n    currentWord.push(current);\n    previous = '';\n  }\n\n  if (previous === '\"') currentWord.pop();\n  if (currentWord.length) result.push(currentWord.join(''));\n\n  return result;\n}\n","import escapeRegExp from 'lodash.escaperegexp';\n\nimport getCheckNumber from './getCheckNumber';\nimport getCheckString from './getCheckString';\nimport parseKeywords from './parseKeywords';\n\nexport function filter(array, options = {}) {\n  let result = [];\n\n  let limit = options.limit || Infinity;\n  let insensitive = options.caseSensitive ? '' : 'i';\n  let keywords = options.keywords || [];\n  if (typeof keywords === 'string') {\n    keywords = parseKeywords(keywords);\n  }\n  keywords = keywords.map(function (keyword) {\n    let criterion = {\n      is: false,\n      key: false,\n      negate: false,\n      valueReg: undefined,\n    };\n\n    if (keyword.charAt(0) === '-') {\n      criterion.negate = true;\n      keyword = keyword.substring(1);\n    }\n    let colon = keyword.indexOf(':');\n    if (colon > -1) {\n      let value = keyword.substring(colon + 1);\n      if (colon > 0) {\n        let key = keyword.substring(0, colon);\n        if (key === 'is') {\n          criterion.is = new RegExp(`^${escapeRegExp(value)}$`, insensitive);\n        }\n        criterion.key = key;\n      }\n      fillCriterion(criterion, value, insensitive);\n    } else {\n      fillCriterion(criterion, keyword, insensitive);\n    }\n\n    return criterion;\n  });\n\n  let index = !!options.index;\n  let matched = 0;\n  for (let i = 0; i < array.length && matched < limit; i++) {\n    if (match(array[i], keywords, options.predicate || 'AND')) {\n      matched = result.push(index ? i : array[i]);\n    }\n  }\n  return result;\n}\n\nfunction fillCriterion(criterion, keyword, insensitive) {\n  criterion.checkString = getCheckString(keyword, insensitive);\n  criterion.checkNumber = getCheckNumber(keyword);\n}\n\nexport function match(element, keywords, predicate) {\n  if (keywords.length) {\n    let found = false;\n    for (let i = 0; i < keywords.length; i++) {\n      // match XOR negate\n      if (\n        recursiveMatch(element, keywords[i])\n          ? !keywords[i].negate\n          : keywords[i].negate\n      ) {\n        if (predicate === 'OR') {\n          return true;\n        }\n        found = true;\n      } else if (predicate === 'AND') {\n        return false;\n      }\n    }\n    return found;\n  }\n  return true;\n}\n\nfunction recursiveMatch(element, keyword, key) {\n  if (typeof element === 'object') {\n    if (Array.isArray(element)) {\n      for (let i = 0; i < element.length; i++) {\n        if (recursiveMatch(element[i], keyword)) {\n          console.log(element[i], keyword);\n          console.log('TRUE');\n          return true;\n        }\n      }\n    } else {\n      for (let i in element) {\n        if (recursiveMatch(element[i], keyword, i)) {\n          return true;\n        }\n      }\n    }\n  } else if (key && keyword.is && keyword.is.test(key)) {\n    return !!element;\n  } else if (!keyword.is) {\n    if (key && keyword.key && key !== keyword.key) return false;\n    return nativeMatch(element, keyword);\n  }\n  return false;\n}\n\nfunction nativeMatch(element, keyword) {\n  if (typeof element === 'string') {\n    return keyword.checkString(element);\n  } else if (typeof element === 'number') {\n    return keyword.checkNumber(element);\n  } else {\n    return false;\n  }\n}\n"],"names":["symbolTag","reRegExpChar","reHasRegExpChar","RegExp","source","freeGlobal","global","Object","freeSelf","self","root","Function","objectToString","prototype","toString","Symbol","symbolProto","undefined","symbolToString","baseToString","value","isObjectLike","call","isSymbol","result","string","test","replace","operators","query","number","insensitive","escapeRegExp","reg","separators","fillCriterion","criterion","keyword","checkString","match","exec","operator","dots","secondQuery","parseFloat","getCheckString","checkNumber","getCheckNumber","element","keywords","predicate","length","found","i","recursiveMatch","negate","key","Array","isArray","console","log","is","nativeMatch","array","options","limit","Infinity","caseSensitive","inQuotes","inSeparator","currentWord","previous","current","charAt","pop","push","join","parseKeywords","map","valueReg","substring","colon","indexOf","index","matched"],"mappings":"6YAaIA,EAAY,kBAMZC,EAAe,sBACfC,EAAkBC,OAAOF,EAAaG,QAGtCC,EAA8B,iBAAVC,GAAsBA,GAAUA,EAAOC,SAAWA,QAAUD,EAGhFE,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKF,SAAWA,QAAUE,KAGxEC,EAAOL,GAAcG,GAAYG,SAAS,cAATA,GAUjCC,EAPcL,OAAOM,UAOQC,SAG7BC,EAASL,EAAKK,OAGdC,EAAcD,EAASA,EAAOF,eAAYI,EAC1CC,EAAiBF,EAAcA,EAAYF,cAAWG,EAU1D,SAASE,EAAaC,MAEA,iBAATA,SACFA,KAsDX,SAAkBA,SACO,iBAATA,GAtBhB,SAAsBA,WACXA,GAAyB,iBAATA,EAsBtBC,CAAaD,IAAUR,EAAeU,KAAKF,IAAUpB,EAtDpDuB,CAASH,UACJF,EAAiBA,EAAeI,KAAKF,GAAS,OAEnDI,EAAUJ,EAAQ,SACJ,KAAVI,GAAkB,EAAIJ,IAvDjB,SAuDwC,KAAOI,EAoG9D,MAPA,SAAsBC,GAnBtB,IAAkBL,SAoBhBK,EAnBgB,OADAL,EAoBEK,GAnBK,GAAKN,EAAaC,KAoBvBlB,EAAgBwB,KAAKD,GACnCA,EAAOE,QAAQ1B,EAAc,QAC7BwB,GClKN,MAAMG,EAAY,KACVC,GACG,SAAUC,UACRA,EAASD,QAGbA,GACE,SAAUC,UACRA,GAAUD,OAGfA,GACG,SAAUC,UACRA,IAAWD,QAGfA,GACE,SAAUC,UACRA,GAAUD,OAGfA,GACG,SAAUC,UACRA,EAASD,IAMtBD,EAAU,MAAQA,EAAU,MC3B5B,MAAMA,EAAY,KACVC,GACG,SAAUJ,UACRA,EAASI,QAGbA,GACE,SAAUJ,UACRA,GAAUI,OAGhB,CAACA,EAAOE,KACXF,EAAS,IAAGG,EAAaH,YACnBI,EAAM,IAAI9B,OAAO0B,EAAOE,UAEvB,SAAUN,UACRQ,EAAIP,KAAKD,SAGf,CAACI,EAAOE,KACXF,EAAQG,EAAaH,SACfI,EAAM,IAAI9B,OAAO0B,EAAOE,UAEvB,SAAUN,UACRQ,EAAIP,KAAKD,UAGbI,GACE,SAAUJ,UACRA,GAAUI,OAGfA,GACG,SAAUJ,UACRA,EAASI,MAKZ,MAAQD,EAAU,MCzC5B,IAAIM,EAAa,cCuDjB,SAASC,EAAcC,EAAWC,EAASN,GACzCK,EAAUE,YFbG,SAAwBD,EAASN,OAC1CQ,EAAQ,iFAAiFC,KAC3FH,GAEEC,EAAc,KAAM,KACpBC,EAAO,KACLE,EAAWF,EAAM,GACjBV,EAAQU,EAAM,GACdG,EAAOH,EAAM,GACbI,EAAcJ,EAAM,GACpBE,EACFH,EAAcV,EAAUa,GAAUZ,EAAOE,GAChCW,EACW,KAAhBC,GACFA,EAAcC,WAAWD,GACzBL,EAAc,SAAUb,UACfI,GAASJ,GAAUA,GAAUkB,IAGtCL,EAAcV,EAAU,MAAMC,EAAOE,GAGvCO,EAAcV,EAAU,KAAKC,EAAOE,UAGjCO,EEZiBO,CAAeR,EAASN,GAChDK,EAAUU,YH1BG,SAAwBT,OACjCE,EAAQ,+EAA+EC,KACzFH,GAEES,EAAc,KAAM,KACpBP,EAAO,KACLE,EAAWF,EAAM,GACjBV,EAAQe,WAAWL,EAAM,IACzBG,EAAOH,EAAM,GACbI,EAAcJ,EAAM,GACpBE,EACFK,EAAclB,EAAUa,GAAUZ,GACzBa,EACW,KAAhBC,GACFA,EAAcC,WAAWD,GACzBG,EAAc,SAAUhB,UACfD,GAASC,GAAUA,GAAUa,IAGtCG,EAAclB,EAAU,MAAMC,GAGhCiB,EAAclB,EAAU,KAAKC,UAG1BiB,EGCiBC,CAAeV,GAGlC,SAASE,EAAMS,EAASC,EAAUC,MACnCD,EAASE,OAAQ,KACfC,GAAQ,MACP,IAAIC,EAAI,EAAGA,EAAIJ,EAASE,OAAQE,OAGjCC,EAAeN,EAASC,EAASI,KAC5BJ,EAASI,GAAGE,OACbN,EAASI,GAAGE,OAChB,IACkB,OAAdL,SACK,EAETE,GAAQ,OACH,GAAkB,QAAdF,SACF,SAGJE,SAEF,EAGT,SAASE,EAAeN,EAASX,EAASmB,MACjB,iBAAZR,MACLS,MAAMC,QAAQV,QACX,IAAIK,EAAI,EAAGA,EAAIL,EAAQG,OAAQE,OAC9BC,EAAeN,EAAQK,GAAIhB,UAC7BsB,QAAQC,IAAIZ,EAAQK,GAAIhB,GACxBsB,QAAQC,IAAI,SACL,WAIN,IAAIP,KAAKL,KACRM,EAAeN,EAAQK,GAAIhB,EAASgB,UAC/B,MAIR,CAAA,GAAIG,GAAOnB,EAAQwB,IAAMxB,EAAQwB,GAAGnC,KAAK8B,WACrCR,EACJ,IAAKX,EAAQwB,WACdL,IAAOnB,EAAQmB,KAAOA,IAAQnB,EAAQmB,MAM9C,SAAqBR,EAASX,SACL,iBAAZW,EACFX,EAAQC,YAAYU,GACC,iBAAZA,GACTX,EAAQS,YAAYE,GATpBc,CAAYd,EAASX,UAEvB,WApGF,SAAgB0B,EAAOC,EAAU,QAClCxC,EAAS,GAETyC,EAAQD,EAAQC,OAASC,EAAAA,EACzBnC,EAAciC,EAAQG,cAAgB,GAAK,IAC3ClB,EAAWe,EAAQf,UAAY,GACX,iBAAbA,IACTA,EDXW,SAAuBA,OAChCzB,EAAS,GACT4C,GAAW,EACXC,GAAc,EACdC,EAAc,GACdC,EAAW,OACV,IAAIlB,EAAI,EAAGA,EAAIJ,EAASE,OAAQE,IAAK,KACpCmB,EAAUvB,EAASwB,OAAOpB,MAC1Be,MACe,MAAbG,EAAkB,IAEJ,MAAZC,EAAiB,CACnBD,EAAW,YAIbD,EAAYI,MACZN,GAAW,EACXf,aAGFiB,EAAYK,KAAKH,GACjBD,EAAWC,UAGTH,EAAa,IAEXnC,EAAWR,KAAK8C,GAAU,CAC5BD,EAAWC,WAGbH,GAAc,EAGA,MAAZG,EAMAtC,EAAWR,KAAK8C,IACdF,EAAYnB,QAAQ3B,EAAOmD,KAAKL,EAAYM,KAAK,KACrDN,EAAc,GACdD,GAAc,IAGhBC,EAAYK,KAAKH,GACjBD,EAAW,KAZTH,GAAW,EACXG,EAAW,WAcE,MAAbA,GAAkBD,EAAYI,MAC9BJ,EAAYnB,QAAQ3B,EAAOmD,KAAKL,EAAYM,KAAK,KAE9CpD,EC1CMqD,CAAc5B,IAE3BA,EAAWA,EAAS6B,KAAI,SAAUzC,OAC5BD,EAAY,CACdyB,IAAI,EACJL,KAAK,EACLD,QAAQ,EACRwB,cAAU9D,GAGc,MAAtBoB,EAAQoC,OAAO,KACjBrC,EAAUmB,QAAS,EACnBlB,EAAUA,EAAQ2C,UAAU,QAE1BC,EAAQ5C,EAAQ6C,QAAQ,QACxBD,GAAS,EAAG,KACV7D,EAAQiB,EAAQ2C,UAAUC,EAAQ,MAClCA,EAAQ,EAAG,KACTzB,EAAMnB,EAAQ2C,UAAU,EAAGC,GACnB,OAARzB,IACFpB,EAAUyB,GAAK,IAAI1D,OAAQ,IAAG6B,EAAaZ,MAAWW,IAExDK,EAAUoB,IAAMA,EAElBrB,EAAcC,EAAWhB,EAAOW,QAEhCI,EAAcC,EAAWC,EAASN,UAG7BK,SAGL+C,IAAUnB,EAAQmB,MAClBC,EAAU,MACT,IAAI/B,EAAI,EAAGA,EAAIU,EAAMZ,QAAUiC,EAAUnB,EAAOZ,IAC/Cd,EAAMwB,EAAMV,GAAIJ,EAAUe,EAAQd,WAAa,SACjDkC,EAAU5D,EAAOmD,KAAKQ,EAAQ9B,EAAIU,EAAMV,YAGrC7B"}